<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Microstrip Field Solver</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --panel-color: #ffffff;
            --primary-color: #2563eb;
            --text-color: #1f2937;
            --border-color: #e5e7eb;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Layout */
        .sidebar {
            width: 320px;
            background-color: var(--panel-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        /* Form Elements */
        h2, h3 { margin-top: 0; font-size: 1.1em; color: #111827; }
        h2 { font-size: 1.4em; margin-bottom: 20px; }

        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; font-size: 0.85em; font-weight: 500; margin-bottom: 5px; color: #4b5563; }

        .input-row { display: flex; gap: 10px; align-items: center; }
        input[type="number"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9em;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #1d4ed8; }
        button:disabled { background-color: #93c5fd; cursor: wait; }

        /* Visualization Area */
        .canvas-container {
            flex: 1;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }

        .overlay-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            font-size: 0.8em;
        }

        /* Output Console */
        .output-panel {
            height: 150px;
            margin-top: 20px;
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Consolas', 'Monaco', monospace;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85em;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        /* Progress Bar */
        .progress-container {
            height: 4px;
            background: #e5e7eb;
            margin-top: 10px;
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }
        .progress-bar {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>

<div class="sidebar">
    <h2>Microstrip Solver</h2>

    <div class="control-group">
        <label>Trace Width (mm)</label>
        <input type="number" id="inp_w" value="3.0" step="0.1">
    </div>
    <div class="control-group">
        <label>Substrate Height (mm)</label>
        <input type="number" id="inp_h" value="1.6" step="0.1">
    </div>
    <div class="control-group">
        <label>Trace Thickness (μm)</label>
        <input type="number" id="inp_t" value="35" step="1">
    </div>
    <div class="control-group">
        <label>Relative Permittivity (&epsilon;<sub>r</sub>)</label>
        <input type="number" id="inp_er" value="4.5" step="0.1">
    </div>
    <div class="control-group">
        <label>Loss Tangent (tan &delta;)</label>
        <input type="number" id="inp_tand" value="0.02" step="0.001">
    </div>
    <div class="control-group">
        <label>Conductivity (S/m)</label>
        <input type="number" id="inp_sigma" value="5.8e7" step="1e6">
    </div>
    <div class="control-group">
        <label>Frequency (GHz)</label>
        <input type="number" id="inp_freq" value="1.0" step="0.1">
    </div>

    <h3>Mesh Settings</h3>
    <div class="control-group">
        <label>Grid Size (Nx / Ny)</label>
        <div class="input-row">
            <input type="number" id="inp_nx" value="100" step="10">
            <input type="number" id="inp_ny" value="100" step="10">
        </div>
    </div>

    <button id="btn_update_geo">Update Geometry</button>
    <div style="height: 10px;"></div>
    <button id="btn_solve">Solve Physics</button>

    <div class="progress-container" id="progress_container">
        <div class="progress-bar" id="progress_bar"></div>
    </div>
</div>

<div class="main-content">
    <div class="canvas-container">
        <div class="overlay-controls">
            <label><input type="checkbox" id="chk_mesh" checked> Show Mesh</label>
            <label>
                View:
                <select id="sel_view_mode">
                    <option value="geometry">Geometry</option>
                    <option value="potential">Potential (V)</option>
                    <option value="efield">|E| Field</option>
                </select>
            </label>
        </div>
        <canvas id="sim_canvas"></canvas>
    </div>

    <div class="output-panel" id="console_out">Ready. Click 'Solve Physics' to start simulation.</div>
</div>

<script>
/**
 * 2D Field Solver Logic (Ported from Python)
 */

const CONSTANTS = {
    EPS0: 8.854187817e-12,
    MU0: 4 * Math.PI * 1e-7,
    C: 299792458,
    PI: Math.PI
};

// --- Math Utils ---

function linspace(start, end, n) {
    if (n <= 1) return [start];
    const arr = new Float64Array(n);
    const step = (end - start) / (n - 1);
    for (let i = 0; i < n; i++) arr[i] = start + i * step;
    return arr;
}

function diff(arr) {
    const res = new Float64Array(arr.length - 1);
    for (let i = 0; i < arr.length - 1; i++) res[i] = arr[i+1] - arr[i];
    return res;
}

function smooth_transition(start, end, n_points, curve_end='end', beta=4.0) {
    if (n_points <= 1) return new Float64Array([start]);
    if (n_points === 2) return new Float64Array([start, end]);

    const xi = linspace(0, 1, n_points);
    const res = new Float64Array(n_points);

    for(let i=0; i<n_points; i++) {
        let eta = 0;
        if (curve_end === 'end') {
            eta = Math.tanh(beta * xi[i]) / Math.tanh(beta);
        } else if (curve_end === 'both') {
            eta = (Math.tanh(beta * (xi[i] - 0.5)) / Math.tanh(beta * 0.5) + 1) / 2;
        } else {
            eta = 1 - Math.tanh(beta * (1 - xi[i])) / Math.tanh(beta);
        }
        res[i] = start + eta * (end - start);
    }
    return res;
}

function buildCSR(rowLists, colLists, valLists, N) {
    let nnz = 0;
    for (let i = 0; i < N; i++) nnz += rowLists[i].length;

    const rowPtr = new Int32Array(N + 1);
    const colIdx = new Int32Array(nnz);
    const values = new Float64Array(nnz);

    let p = 0;
    for (let i = 0; i < N; i++) {
        rowPtr[i] = p;
        const cols = colLists[i];
        const vals = valLists[i];
        for (let k = 0; k < cols.length; k++) {
            colIdx[p] = cols[k];
            values[p] = vals[k];
            p++;
        }
    }
    rowPtr[N] = p;

    return { rowPtr, colIdx, values };
}


// --- Solver Class ---

class FieldSolver2D {
    constructor() {
        this.x = null;
        this.y = null;
        this.V = null;
        this.epsilon_r = null;
        this.conductor_mask = null; // 1 if conductor, 0 if dielectric
        this.bc_mask = null; // Boundary conditions
        this.solution_valid = false;

        // Computed fields
        this.Ex = null;
        this.Ey = null;
    }

    async solve_laplace_iterative(vacuum = false, onProgress = null) {
        const ny = this.y.length, nx = this.x.length;
        const dx = diff(this.x), dy = diff(this.y);
        const N = nx * ny;
        const idx = (i, j) => i * nx + j;

        const get_er = (i, j) => vacuum ? 1.0 : this.epsilon_r[i][j];
        const is_cond = (i, j) => this.conductor_mask[i][j];

        // --- Reduced system mapping ---
        const is_unknown = new Int8Array(N);
        let N_unknown = 0;

        for (let i = 0; i < ny; i++)
            for (let j = 0; j < nx; j++) {
                const n = idx(i, j);
                if (!is_cond(i, j)) {
                    is_unknown[n] = 1;
                    N_unknown++;
                }
            }

        const full_to_red = new Int32Array(N).fill(-1);
        const red_to_full = new Int32Array(N_unknown);

        let k = 0;
        for (let n = 0; n < N; n++) {
            if (is_unknown[n]) {
                full_to_red[n] = k;
                red_to_full[k] = n;
                k++;
            }
        }

        // --- Build sparse system (lists first) ---
        const rows = Array(N_unknown);
        const cols = Array(N_unknown);
        const vals = Array(N_unknown);
        const B = new Float64Array(N_unknown);
        const diag = new Float64Array(N_unknown);

        for (let i = 0; i < N_unknown; i++) {
            rows[i] = [];
            cols[i] = [];
            vals[i] = [];
        }

        const addA = (r, c, v) => {
            rows[r].push(c);
            vals[r].push(v);
            if (r === c) diag[r] += v;
        };

        // --- Matrix assembly (Python parity) ---
        for (let i = 0; i < ny; i++) {
            for (let j = 0; j < nx; j++) {
                if (is_cond(i, j)) continue;

                const fn = idx(i, j);
                const n = full_to_red[fn];

                const boundary =
                    i === 0 || i === ny - 1 || j === 0 || j === nx - 1;

                let dxr, dxl, dyu, dyd;
                if (boundary) {
                    dxr = j < nx - 1 ? dx[j] : dx[j - 1];
                    dxl = j > 0 ? dx[j - 1] : dx[j];
                    dyu = i < ny - 1 ? dy[i] : dy[i - 1];
                    dyd = i > 0 ? dy[i - 1] : dy[i];
                } else {
                    dxr = dx[j];
                    dxl = dx[j - 1];
                    dyu = dy[i];
                    dyd = dy[i - 1];
                }

                let err, erl, eru, erd;
                if (vacuum) {
                    err = erl = eru = erd = 1.0;
                } else {
                    const erc = get_er(i, j);
                    if (boundary) {
                        err = 0.5 * (erc + get_er(i, Math.min(j + 1, nx - 1)));
                        erl = 0.5 * (erc + get_er(i, Math.max(j - 1, 0)));
                        eru = 0.5 * (erc + get_er(Math.min(i + 1, ny - 1), j));
                        erd = 0.5 * (erc + get_er(Math.max(i - 1, 0), j));
                    } else {
                        err = is_cond(i, j + 1) ? erc : 0.5 * (erc + get_er(i, j + 1));
                        erl = is_cond(i, j - 1) ? erc : 0.5 * (erc + get_er(i, j - 1));
                        eru = is_cond(i + 1, j) ? erc : 0.5 * (erc + get_er(i + 1, j));
                        erd = is_cond(i - 1, j) ? erc : 0.5 * (erc + get_er(i - 1, j));
                    }
                }

                const area_i = 0.5 * (dyd + dyu);
                const area_j = 0.5 * (dxl + dxr);

                let cr, cl, cu, cd;
                if (boundary) {
                    cr = j < nx - 1 ? -err * area_i / dxr : 0;
                    cl = j > 0 ? -erl * area_i / dxl : 0;
                    cu = i < ny - 1 ? -eru * area_j / dyu : 0;
                    cd = i > 0 ? -erd * area_j / dyd : 0;
                } else {
                    cr = -err * area_i / dxr;
                    cl = -erl * area_i / dxl;
                    cu = -eru * area_j / dyu;
                    cd = -erd * area_j / dyd;
                }

                const cc = -(cr + cl + cu + cd);
                addA(n, n, cc);

                const handle = (ii, jj, c) => {
                    const fn2 = idx(ii, jj);
                    if (!is_cond(ii, jj)) {
                        addA(n, full_to_red[fn2], c);
                    } else {
                        B[n] -= c * this.V[ii][jj];
                    }
                };

                if (j < nx - 1) handle(i, j + 1, cr);
                if (j > 0) handle(i, j - 1, cl);
                if (i < ny - 1) handle(i + 1, j, cu);
                if (i > 0) handle(i - 1, j, cd);
            }
        }

        // --- Convert to CSR ---
        const { rowPtr, colIdx, values } = buildCSR(rows, rows, vals, N_unknown);

        // --- Preconditioned CG ---
        const x = new Float64Array(N_unknown);
        const r = new Float64Array(N_unknown);
        const z = new Float64Array(N_unknown);
        const p = new Float64Array(N_unknown);
        const Ap = new Float64Array(N_unknown);
        const invDiag = new Float64Array(N_unknown);

        for (let i = 0; i < N_unknown; i++) invDiag[i] = 1.0 / diag[i];

        let bnorm = 0;
        for (let i = 0; i < N_unknown; i++) {
            r[i] = B[i];
            bnorm += B[i] * B[i];
        }
        bnorm = Math.sqrt(bnorm);

        const rtol = 1e-7;
        const atol = 1e-12;
        const maxIter = 10000;

        for (let i = 0; i < N_unknown; i++) {
            z[i] = r[i] * invDiag[i];
            p[i] = z[i];
        }

        let rz_old = 0;
        for (let i = 0; i < N_unknown; i++) rz_old += r[i] * z[i];

        for (let iter = 0; iter < maxIter; iter++) {
            // Ap = A * p
            for (let i = 0; i < N_unknown; i++) {
                let sum = 0;
                for (let k = rowPtr[i]; k < rowPtr[i + 1]; k++) {
                    sum += values[k] * p[colIdx[k]];
                }
                Ap[i] = sum;
            }

            let alpha_den = 0;
            for (let i = 0; i < N_unknown; i++) {
                alpha_den += p[i] * Ap[i];
            }

            const alpha = rz_old / alpha_den;

            let err = 0;
            for (let i = 0; i < N_unknown; i++) {
                x[i] += alpha * p[i];
                r[i] -= alpha * Ap[i];
                err += r[i] * r[i];
            }

            const rnorm = Math.sqrt(err);
            if (rnorm <= rtol * bnorm + atol) break;

            for (let i = 0; i < N_unknown; i++) {
                z[i] = r[i] * invDiag[i];
            }

            let rz_new = 0;
            for (let i = 0; i < N_unknown; i++) rz_new += r[i] * z[i];

            const beta = rz_new / rz_old;
            rz_old = rz_new;

            for (let i = 0; i < N_unknown; i++) {
                p[i] = z[i] + beta * p[i];
            }

            if (iter % 100 === 0 && onProgress) {
                onProgress(iter, maxIter, rnorm / bnorm);
                await new Promise(r => setTimeout(r, 0));
            }
        }

        // --- Reconstruct solution ---
        for (let k = 0; k < N_unknown; k++) {
            const n = red_to_full[k];
            const i = (n / nx) | 0;
            const j = n % nx;
            this.V[i][j] = x[k];
        }
    }

    compute_fields() {
        const ny = this.y.length;
        const nx = this.x.length;
        const dx = diff(this.x);
        const dy = diff(this.y);

        this.Ex = Array(ny).fill().map(() => new Float64Array(nx));
        this.Ey = Array(ny).fill().map(() => new Float64Array(nx));

        for(let i=1; i<ny-1; i++) {
            for(let j=1; j<nx-1; j++) {
                if (this.conductor_mask[i][j]) continue;

                const dxl = dx[j-1];
                const dxr = dx[j];
                const dyd = dy[i-1];
                const dyu = dy[i];

                this.Ex[i][j] = -(
                    (dxl / (dxr * (dxl + dxr))) * this.V[i][j+1] +
                    ((dxr - dxl) / (dxl * dxr)) * this.V[i][j] -
                    (dxr / (dxl * (dxl + dxr))) * this.V[i][j-1]
                );

                this.Ey[i][j] = -(
                    (dyd / (dyu * (dyd + dyu))) * this.V[i+1][j] +
                    ((dyu - dyd) / (dyd * dyu)) * this.V[i][j] -
                    (dyu / (dyd * (dyd + dyu))) * this.V[i-1][j]
                );
            }
        }
        this.solution_valid = true;
    }

    calculate_capacitance(vacuum=false) {
        let Q = 0.0;
        const ny = this.y.length;
        const nx = this.x.length;
        const dx = diff(this.x);
        const dy = diff(this.y);

        const get_dx = j => j < dx.length ? dx[j] : dx[dx.length-1];
        const get_dy = i => i < dy.length ? dy[i] : dy[dy.length-1];

        // Iterate over signal trace interface
        for (let i = 1; i < ny - 1; i++) {
            for (let j = 1; j < nx - 1; j++) {
                if (!this.signal_mask[i][j]) continue;

                // Check 4 neighbors
                const check_neighbor = (ni, nj, is_vertical_flux) => {
                    if (this.signal_mask[ni][nj]) return; // Internal to conductor

                    // E-field Normal
                    let En;
                    let dist;
                    let area;

                    if (is_vertical_flux) {
                         // Neighbor is Top/Bottom
                         dist = Math.abs(this.y[i] - this.y[ni]);
                         En = (this.V[i][j] - this.V[ni][nj]) / dist;
                         // Average dx for area
                         area = (get_dx(j-1) + get_dx(j)) / 2;
                    } else {
                        // Neighbor is Left/Right
                        dist = Math.abs(this.x[j] - this.x[nj]);
                        En = (this.V[i][j] - this.V[ni][nj]) / dist;
                        // Average dy for area
                        area = (get_dy(i-1) + get_dy(i)) / 2;
                    }

                    const er = vacuum ? 1 : this.epsilon_r[ni][nj];
                    Q += CONSTANTS.EPS0 * er * En * area;
                };

                check_neighbor(i, j+1, false); // Right
                check_neighbor(i, j-1, false); // Left
                check_neighbor(i+1, j, true);  // Top
                check_neighbor(i-1, j, true);  // Bottom
            }
        }
        return Math.abs(Q);
    }
}

class MicrostripSolver extends FieldSolver2D {
    constructor(w, h, t, er, tand, sigma, freq, nx, ny) {
        super();
        this.w = w;
        this.h = h;
        this.t = t;
        this.er = er;
        this.tand = tand;
        this.sigma = sigma;
        this.freq = freq;
        this.omega_freq = 2 * Math.PI * freq;
        
        // Requirements
        this.nx_req = nx;
        this.ny_req = ny;

        // Physical Constants (assuming global or define here)
        this.MU0 = 4 * Math.PI * 1e-7; 

        // Derived geometry
        this.domain_width = 2 * Math.max(this.w * 8, this.h * 15);
        this.top_air = this.h * 15; // Matched Python 'h * 15' default

        // Coordinates (Y)
        this.y_gnd_bot_start = 0;
        this.y_gnd_bot_end = 0; // Assuming thin ground for this model unless t_gnd specified
        this.y_sub_start = 0;
        this.y_sub_end = this.h;
        this.y_trace_start = this.h;
        this.y_trace_end = this.h + this.t;
        this.y_top_start = this.y_trace_end;
        this.y_top_end = this.y_top_start + this.top_air;

        this.generate_grid();
    }

    generate_grid() {
        this.delta_s = Math.sqrt(2 / (this.omega_freq * this.MU0 * this.sigma));

        // Generate Grids
        this.x = this._grid_x(this.nx_req);
        this.y = this._grid_y(this.ny_req);

        // Compute differentials (dx, dy) for solver use
        this.dx = new Float64Array(this.x.length - 1);
        for(let i=0; i<this.x.length-1; i++) this.dx[i] = this.x[i+1] - this.x[i];

        this.dy = new Float64Array(this.y.length - 1);
        for(let i=0; i<this.y.length-1; i++) this.dy[i] = this.y[i+1] - this.y[i];

        this.init_matrices();
    }

    // --- X Grid Generation Port ---
    _grid_x(n) {
        const cx = this.domain_width / 2;
        const xl = cx - this.w / 2;
        const xr = cx + this.w / 2;

        const ds = this.delta_s;
        const corner = Math.min(3 * ds, this.w / 4);
        const ncorner = Math.max(3, Math.floor(n / 40));

        // Critical X Interfaces
        let x_if = [0, xl, xr, this.domain_width];
        // Sort and Unique
        x_if = Float64Array.from(new Set(x_if)).sort();

        const n_regions = x_if.length - 1;

        // 1. Calculate Weights
        let region_weights = [];
        for (let k = 0; k < n_regions; k++) {
            const x0 = x_if[k];
            const x1 = x_if[k + 1];
            const width = x1 - x0;
            let weight = 1.0;

            // Trace Region check (using epsilon tolerance)
            if (x0 >= xl - 1e-15 && x1 <= xr + 1e-15) {
                weight = 6.0; // High weight for trace
            }
            region_weights.push(weight * width);
        }

        // 2. Allocate Points
        const total_weight = region_weights.reduce((a, b) => a + b, 0);
        let region_points = [];
        let allocated = 0;

        for (let k = 0; k < n_regions; k++) {
            let pts;
            if (k === n_regions - 1) {
                pts = n - allocated;
            } else {
                pts = Math.max(3, Math.floor(n * region_weights[k] / total_weight));
            }
            region_points.push(pts);
            allocated += pts;
        }

        // 3. Generate Segments
        let x_parts = [];
        for (let k = 0; k < n_regions; k++) {
            const x0 = x_if[k];
            const x1 = x_if[k + 1];
            const npts = region_points[k];
            let seg;

            if (x0 >= xl - 1e-15 && x1 <= xr + 1e-15) {
                // --- TRACE REGION (Complex Grading) ---
                const nc = Math.min(ncorner, Math.floor(npts / 3));
                const n_mid = Math.max(3, npts - 2 * nc);

                const corner_left = Math.min(corner, (x1 - x0) / 3);
                const corner_right = Math.min(corner, (x1 - x0) / 3);

                let cl, cr;

                // Left Corner
                if (nc > 0 && corner_left > 1e-15) {
                    cl = this._smooth_transition(x0, x0 + corner_left, nc, 'start', 4.0);
                } else {
                    cl = new Float64Array([x0]);
                }

                // Middle
                const mid0 = x0 + corner_left;
                const mid1 = Math.max(x1 - corner_right, mid0);
                const mid = this._smooth_transition(mid0, mid1, n_mid, 'both', 4.0);

                // Right Corner
                if (nc > 0 && corner_right > 1e-15) {
                    cr = this._smooth_transition(mid1, x1, nc, 'end', 4.0);
                } else {
                    cr = new Float64Array([x1]);
                }

                // Concatenate Trace parts: cl + mid[1:] + cr[1:]
                seg = this._concat_arrays([cl, mid.subarray(1), cr.subarray(1)]);

            } else {
                // --- AIR / DIELECTRIC REGION ---
                let end_curve = "both";
                let beta_val = 3.0;

                // Edges of Domain
                if (Math.abs(x0) < 1e-15) {
                    end_curve = "end"; // Dense right
                } else if (Math.abs(x1 - this.domain_width) < 1e-15) {
                    end_curve = "start"; // Dense left
                }

                // Edges of Trace
                if (x1 <= xl + 1e-15 || x0 >= xr - 1e-15) {
                    if (x1 <= xl + 1e-15) end_curve = "end";
                    else end_curve = "start";
                    beta_val = 4.0;
                }

                seg = this._smooth_transition(x0, x1, npts, end_curve, beta_val);
            }

            // Stitching: Skip first point for segments after the first one
            if (k > 0) {
                seg = seg.subarray(1);
            }
            x_parts.push(seg);
        }

        let x = this._concat_arrays(x_parts);

        // 4. Enforce Interfaces (Inject points if missed)
        x = this._enforce_interfaces(x, x_if);

        return x;
    }

    // --- Y Grid Generation Port ---
    _grid_y(n) {
        const ds = this.delta_s;
        const corner = Math.min(3 * ds, this.t / 4);
        const ncorner = Math.max(3, Math.floor(n / 40));

        // Critical Y Interfaces
        let y_if = [
            this.y_gnd_bot_start,
            this.y_gnd_bot_end, // likely 0 if t_gnd=0, unique will handle it
            this.y_sub_start,
            this.y_sub_end,
            this.y_trace_start,
            this.y_trace_end,
            this.y_top_start,
            this.y_top_end
        ];
        y_if = Float64Array.from(new Set(y_if)).sort();
        const n_regions = y_if.length - 1;

        // 1. Weights
        let region_weights = [];
        for (let k = 0; k < n_regions; k++) {
            const y0 = y_if[k];
            const y1 = y_if[k + 1];
            const height = y1 - y0;
            let weight = 0.1; // Default Air

            if (y0 >= this.y_trace_start - 1e-15 && y1 <= this.y_trace_end + 1e-15) {
                weight = 10.0; // Trace
            } else if (y1 <= this.y_gnd_bot_end + 1e-15) {
                weight = 0.0; // Ground (metal thickness)
            } else if (y0 >= this.y_sub_start - 1e-15 && y1 <= this.y_sub_end + 1e-15) {
                weight = 0.75; // Substrate
            }
            
            region_weights.push(weight * height);
        }

        // 2. Allocate
        const total_weight = region_weights.reduce((a, b) => a + b, 0);
        let region_points = [];
        let allocated = 0;
        
        for (let k = 0; k < n_regions; k++) {
            let pts;
            if (k === n_regions - 1) pts = n - allocated;
            else pts = Math.max(3, Math.floor(n * region_weights[k] / total_weight));
            region_points.push(pts);
            allocated += pts;
        }

        // 3. Segments
        let y_parts = [];
        for (let k = 0; k < n_regions; k++) {
            const y0 = y_if[k];
            const y1 = y_if[k + 1];
            const npts = region_points[k];
            let seg;
            let end_curve = "both";
            let beta_val = 3.0;

            if (Math.abs(y0) < 1e-15) {
                end_curve = "end";
                beta_val = 4.0;
            }

            if (y0 >= this.y_trace_start - 1e-15 && y1 <= this.y_trace_end + 1e-15) {
                // --- TRACE (Vertical) ---
                const nc = Math.min(ncorner, Math.floor(npts / 3));
                const n_mid = Math.max(4, npts - 2 * nc);
                
                const corner_bot = Math.min(corner, (y1 - y0)/3);
                const corner_top = Math.min(corner, (y1 - y0)/3);
                
                let cb, ct;

                // Bottom Corner
                if (nc > 0 && corner_bot > 1e-15) {
                    cb = this._smooth_transition(y0, y0 + corner_bot, nc, 'start', 4.0);
                } else {
                    cb = new Float64Array([y0]);
                }

                // Mid
                const mid0 = y0 + corner_bot;
                const mid1 = Math.max(y1 - corner_top, mid0);
                const mid = this._smooth_transition(mid0, mid1, n_mid, 'both', 2.0);

                // Top Corner
                if (nc > 0 && corner_top > 1e-15) {
                    ct = this._smooth_transition(mid1, y1, nc, 'end', 4.0);
                } else {
                    ct = new Float64Array([y1]);
                }

                seg = this._concat_arrays([cb, mid.subarray(1), ct.subarray(1)]);

            } else if (y0 >= this.y_sub_start - 1e-15 && y1 <= this.y_sub_end + 1e-15) {
                // Substrate
                seg = this._smooth_transition(y0, y1, npts, 'end', 3.5);
            } else {
                // Air / Others
                seg = this._smooth_transition(y0, y1, npts, end_curve, beta_val);
            }

            if (k > 0) seg = seg.subarray(1);
            y_parts.push(seg);
        }

        let y = this._concat_arrays(y_parts);
        y = this._enforce_interfaces(y, y_if);

        return y;
    }

    _smooth_transition(x0, x1, n, curve_end, beta) {
        // Standard geometric/hyperbolic grading logic
        // Matches typical Python solvers' behavior given parameters
        const pts = new Float64Array(n);
        for(let i=0; i<n; i++) {
            let u = i / (n - 1);
            let val;
            
            // Note: Different solvers use different map functions (sinh, tanh, power).
            // A robust "beta" based map often implies a Tanh or geometric progression.
            // Using Tanh map to support 'both' grading effectively.
            if(n <= 1) { pts[i] = x0; continue; }

            if (curve_end === 'start') {
                // Dense at start: u^beta
                val = Math.pow(u, beta);
            } else if (curve_end === 'end') {
                // Dense at end: 1 - (1-u)^beta
                val = 1.0 - Math.pow(1.0 - u, beta);
            } else {
                // Both: Tanh sigmoid map 
                // Map u [0,1] to [-1, 1], apply tanh, remap back
                const u_map = 2 * u - 1;
                const top = Math.tanh(beta * u_map);
                const bot = Math.tanh(beta);
                val = 0.5 * (1 + top / bot);
            }
            pts[i] = x0 + (x1 - x0) * val;
        }
        return pts;
    }

    _enforce_interfaces(arr, interfaces) {
        // If an interface point is missing (distance > tol), inject it
        const tol = 1e-12;
        let list = Array.from(arr);
        let changed = false;

        for (let val of interfaces) {
            let min_dist = Number.MAX_VALUE;
            for(let p of list) min_dist = Math.min(min_dist, Math.abs(p - val));
            
            if (min_dist > tol) {
                list.push(val);
                changed = true;
            }
        }
        if(changed) {
            return Float64Array.from(new Set(list)).sort();
        }
        return arr;
    }

    _concat_arrays(arrays) {
        let totalLen = 0;
        for(let a of arrays) totalLen += a.length;
        let res = new Float64Array(totalLen);
        let offset = 0;
        for(let a of arrays) {
            res.set(a, offset);
            offset += a.length;
        }
        return res;
    }

    init_matrices() {
        const nx = this.x.length;
        const ny = this.y.length;

        // Initialize 2D Arrays (in Row-Major: [ny][nx])
        this.epsilon_r = Array(ny).fill().map(() => new Float64Array(nx).fill(1.0));
        this.conductor_mask = Array(ny).fill().map(() => new Uint8Array(nx).fill(0));
        this.signal_mask = Array(ny).fill().map(() => new Uint8Array(nx).fill(0));
        this.ground_mask = Array(ny).fill().map(() => new Uint8Array(nx).fill(0));
        this.V = Array(ny).fill().map(() => new Float64Array(nx).fill(0.0));

        const tol = 1e-11;
        const cx = this.domain_width / 2;
        const xl = cx - this.w/2;
        const xr = cx + this.w/2;

        // Iterate exactly as Python _setup_geometry
        for (let i = 0; i < ny; i++) {
            const yc = this.y[i];

            // 1. Permittivity (Row operation)
            // Python: if yc <= y_sub_end: er, else: er_top
            const is_sub = (yc - tol <= this.y_sub_end + tol);
            const val = is_sub ? this.er : (this.er_top || 1.0); // Handle er_top if exists
            
            for(let j=0; j<nx; j++) {
                this.epsilon_r[i][j] = val;
            }

            // 2. Bottom Ground
            if (yc >= this.y_gnd_bot_start - tol && yc <= this.y_gnd_bot_end + tol) {
                for(let j=0; j<nx; j++) this.ground_mask[i][j] = 1;
            }

            // 3. Trace
            if (yc >= this.y_trace_start - tol && yc <= this.y_trace_end + tol) {
                for(let j=0; j<nx; j++) {
                    const xc = this.x[j];
                    if (xc >= xl - tol && xc <= xr + tol) {
                        this.signal_mask[i][j] = 1;
                    }
                }
            }
        }

        // Finalize Potentials
        for(let i=0; i<ny; i++) {
            for(let j=0; j<nx; j++) {
                if(this.signal_mask[i][j]) {
                    this.V[i][j] = 1.0;
                    this.conductor_mask[i][j] = 1;
                } else if (this.ground_mask[i][j]) {
                    this.V[i][j] = 0.0;
                    this.conductor_mask[i][j] = 1;
                }
            }
        }
    }

    calculate_losses(Z0) {
        // Dielectric Loss
        let Pd = 0.0;
        const dx = diff(this.x);
        const dy = diff(this.y);

        for (let i = 0; i < this.y.length - 1; i++) {
            for (let j = 0; j < this.x.length - 1; j++) {
                if (this.conductor_mask[i][j]) continue;
                if (this.epsilon_r[i][j] <= 1.01) continue;

                const E2 = this.Ex[i][j]**2 + this.Ey[i][j]**2;
                const area = dx[j] * dy[i];
                Pd += 0.5 * this.omega_freq * CONSTANTS.EPS0 * this.epsilon_r[i][j] * this.tand * E2 * area;
            }
        }

        const P_flow = 1.0 / (2 * Z0);
        const alpha_diel = 8.686 * (Pd / (2 * P_flow));

        // Conductor loss (Approximation using Perturbation)
        // Simplified: Alpha_c approx R_s / (Z0 * w) * geometric_factors
        // For accurate result, we need the surface integral of H-field.
        // Given JS constraints, using Wheeler's incremental inductance or simple perturbation.
        // Let's implement the loop integral used in Python script.

        const Rs = Math.sqrt(this.omega_freq * CONSTANTS.MU0 / (2 * this.sigma));
        const Z0_vac = 376.73;
        let Pc = 0.0;

        const get_dl = (idx, axis) => axis === 'x' ? 
            (idx < dx.length ? dx[idx] : dx[dx.length-1]) : 
            (idx < dy.length ? dy[idx] : dy[dy.length-1]);

        // Iterate interface cells
        // Simplified loop over signal mask boundaries
        // ... (Omitting complex path integration for brevity, using high-freq approx) ...
        // Using approximate formula for demo purposes if integration is too heavy:
        // alpha_c = 8.686 * Rs / (2 * Z0 * w) (Very rough)
        // Let's try to do the loop sum on signal trace only

        let sum_H2_dl = 0;

        for (let i=1; i<this.y.length-1; i++) {
            for (let j=1; j<this.x.length-1; j++) {
                if (!this.signal_mask[i][j]) continue;

                // Look for dielectric neighbors
                const neighbors = [
                    {di: 0, dj: 1, dist: get_dl(i, 'y')},
                    {di: 0, dj: -1, dist: get_dl(i, 'y')},
                    {di: 1, dj: 0, dist: get_dl(j, 'x')},
                    {di: -1, dj: 0, dist: get_dl(j, 'x')}
                ];

                for (let nb of neighbors) {
                    const ni = i + nb.di;
                    const nj = j + nb.dj;
                    if (!this.signal_mask[ni][nj]) {
                        // It's an edge
                        const E_norm = Math.sqrt(this.Ex[ni][nj]**2 + this.Ey[ni][nj]**2);
                        const er = this.epsilon_r[ni][nj];
                        // H_tan = E_norm * sqrt(er) / Z0_vac
                        const H_tan = E_norm * Math.sqrt(er) / Z0_vac;
                        sum_H2_dl += (H_tan**2) * nb.dist;
                    }
                }
            }
        }

        // Add ground contribution (approx 50% of trace for microstrip usually, but let's just use trace * factor)
        // Better: Just use trace integral * 2 for rough estimate
        const Pc_est = 0.5 * Rs * sum_H2_dl * 2.0;
        const alpha_cond = 8.686 * Pc_est / (2 * P_flow);

        return { alpha_diel, alpha_cond };
    }
}

// --- App Logic ---

const App = {
    solver: null,
    canvas: document.getElementById('sim_canvas'),
    ctx: document.getElementById('sim_canvas').getContext('2d'),

    init() {
        this.bindEvents();
        this.updateGeometry();
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    },

    bindEvents() {
        document.getElementById('btn_update_geo').onclick = () => {
            this.updateGeometry();
            this.draw();
        };
        document.getElementById('btn_solve').onclick = () => this.runSimulation();

        ['chk_mesh', 'sel_view_mode'].forEach(id => {
            document.getElementById(id).onchange = () => this.draw();
        });
    },

    getParams() {
        return {
            w: parseFloat(document.getElementById('inp_w').value) * 1e-3,
            h: parseFloat(document.getElementById('inp_h').value) * 1e-3,
            t: parseFloat(document.getElementById('inp_t').value) * 1e-6,
            er: parseFloat(document.getElementById('inp_er').value),
            tand: parseFloat(document.getElementById('inp_tand').value),
            sigma: parseFloat(document.getElementById('inp_sigma').value),
            freq: parseFloat(document.getElementById('inp_freq').value) * 1e9,
            nx: parseInt(document.getElementById('inp_nx').value),
            ny: parseInt(document.getElementById('inp_ny').value),
        };
    },

    updateGeometry() {
        const p = this.getParams();
        this.solver = new MicrostripSolver(p.w, p.h, p.t, p.er, p.tand, p.sigma, p.freq, p.nx, p.ny);
        this.log("Geometry updated. Grid: " + this.solver.x.length + "x" + this.solver.y.length);
    },

    async runSimulation() {
        const btn = document.getElementById('btn_solve');
        const pbar = document.getElementById('progress_bar');
        const pcont = document.getElementById('progress_container');

        btn.disabled = true;
        pcont.style.display = 'block';
        this.log("Starting simulation...");

        try {
            // 1. Solve with Dielectric
            this.log("Step 1/2: Solving field with dielectric...");
            await this.solver.solve_laplace_iterative(false, (i, max, diff) => {
                const pct = (i / max) * 50;
                pbar.style.width = pct + "%";
            });
            const C = this.solver.calculate_capacitance(false);

            // Compute fields for loss calculation and visualization
            this.solver.compute_fields();
            this.draw(); // Update view with fields

            // 2. Solve with Vacuum
            this.log("Step 2/2: Solving field with vacuum...");

            // Backup Voltage from Step 1 to restore for visualization later
            const V_diel = this.solver.V.map(row => new Float64Array(row));
            const Ex_diel = this.solver.Ex;
            const Ey_diel = this.solver.Ey;

            // Reset V for vacuum solve
            this.solver.V = this.solver.V.map((row, i) => 
                row.map((val, j) => this.solver.conductor_mask[i][j] ? val : 0)
            );

            await this.solver.solve_laplace_iterative(true, (i, max, diff) => {
                const pct = 50 + (i / max) * 50;
                pbar.style.width = pct + "%";
            });
            const C0 = this.solver.calculate_capacitance(true);

            // 3. Post Process
            const eps_eff = C / C0;
            const Z0 = 1 / (CONSTANTS.C * Math.sqrt(C * C0));

            // Restore dielectric fields for loss calc
            this.solver.V = V_diel;
            this.solver.Ex = Ex_diel;
            this.solver.Ey = Ey_diel;

            const losses = this.solver.calculate_losses(Z0);

            this.log(`\nRESULTS:\n` +
                     `----------------------\n` +
                     `Capacitance:   ${(C*1e12).toFixed(2)} pF/m\n` +
                     `Z0:            ${Z0.toFixed(2)} Ω\n` +
                     `Eps_eff:       ${eps_eff.toFixed(3)}\n` +
                     `Dielectric Loss: ${losses.alpha_diel.toFixed(4)} dB/m\n` +
                     `Conductor Loss:  ${losses.alpha_cond.toFixed(4)} dB/m\n` +
                     `Total Loss:      ${(losses.alpha_diel + losses.alpha_cond).toFixed(4)} dB/m`);

        } catch (e) {
            console.error(e);
            this.log("Error: " + e.message);
        } finally {
            btn.disabled = false;
            pcont.style.display = 'none';
        }
    },

    resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        if(this.solver) this.draw();
    },

    draw() {
        if (!this.solver) return;
        const w = this.canvas.width;
        const h = this.canvas.height;
        this.ctx.clearRect(0, 0, w, h);

        const viewMode = document.getElementById('sel_view_mode').value;
        const showMesh = document.getElementById('chk_mesh').checked;

        // Scaling
        // Find bounding box to fit in canvas with margin
        const domainW = this.solver.domain_width;
        // Limit display Y to relevant area (up to 5x trace height)
        const maxY = Math.min(this.solver.y.slice(-1)[0], this.solver.h + 5 * this.solver.w);
        const domainH = maxY;

        const scaleX = (w - 40) / domainW;
        const scaleY = (h - 40) / domainH;
        const scale = Math.min(scaleX, scaleY);

        const offsetX = (w - domainW * scale) / 2;
        const offsetY = h - (h - domainH * scale) / 2; // Bottom origin

        const toScreenX = (x) => offsetX + x * scale;
        const toScreenY = (y) => offsetY - y * scale;

        // Helper to draw Rects
        const drawCell = (i, j, color) => {
            const x0 = toScreenX(this.solver.x[j]);
            const y0 = toScreenY(this.solver.y[i]);
            // dx/dy are widths
            const x1 = toScreenX(this.solver.x[j+1]);
            const y1 = toScreenY(this.solver.y[i+1]);

            this.ctx.fillStyle = color;
            this.ctx.fillRect(x0, y1, x1-x0, y0-y1); // Canvas Y inverted
        };

        // Draw Field / Geometry
        const ny = this.solver.y.length;
        const nx = this.solver.x.length;

        // Determine min/max for colormapping
        let maxVal = 0;
        if (viewMode === 'efield' && this.solver.solution_valid) {
             for(let i=0; i<ny; i++) 
                for(let j=0; j<nx; j++) 
                     maxVal = Math.max(maxVal, Math.sqrt(this.solver.Ex[i][j]**2 + this.solver.Ey[i][j]**2));
        }

        for (let i = 0; i < ny - 1; i++) {
            if (this.solver.y[i] > maxY) break;

            for (let j = 0; j < nx - 1; j++) {
                let color;

                if (viewMode === 'geometry') {
                    if (this.solver.conductor_mask[i][j]) {
                        color = this.solver.ground_mask[i][j] ? '#333' : '#d97706'; // Dark gnd, Orange trace
                    } else {
                        // Substrate vs Air
                        const er = this.solver.epsilon_r[i][j];
                        color = er > 1.1 ? `rgba(100, 200, 100, ${0.2 + er/10})` : '#fff';
                    }
                } else if (viewMode === 'potential' && this.solver.solution_valid) {
                    if (this.solver.conductor_mask[i][j]) {
                         color = this.solver.ground_mask[i][j] ? '#000' : '#d97706';
                    } else {
                        const v = this.solver.V[i][j];
                        color = this.viridis(v);
                    }
                } else if (viewMode === 'efield' && this.solver.solution_valid) {
                    const emag = Math.sqrt(this.solver.Ex[i][j]**2 + this.solver.Ey[i][j]**2);
                    color = this.viridis(Math.pow(emag / (maxVal || 1), 0.5)); // Gamma correct
                } else {
                    color = '#eee';
                }

                drawCell(i, j, color);
            }
        }

        // Draw Mesh Lines
        if (showMesh) {
            this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();

            // V lines
            for(let j=0; j<nx; j++) {
                const x = toScreenX(this.solver.x[j]);
                this.ctx.moveTo(x, toScreenY(0));
                this.ctx.lineTo(x, toScreenY(maxY));
            }
            // H lines
            for(let i=0; i<ny; i++) {
                if (this.solver.y[i] > maxY) break;
                const y = toScreenY(this.solver.y[i]);
                this.ctx.moveTo(toScreenX(0), y);
                this.ctx.lineTo(toScreenX(domainW), y);
            }
            this.ctx.stroke();
        }
    },

    viridis(t) {
        // Simple heatmap approximation
        t = Math.max(0, Math.min(1, t));
        // R, G, B interpolation
        const r = Math.floor(255 * Math.sin(t * 2));
        const g = Math.floor(255 * Math.sin(t * 3));
        const b = Math.floor(255 * Math.cos(t * 1.5));
        // Better pseudocolor: (Blue -> Cyan -> Green -> Yellow -> Red)
        // Manual standard mapping for clarity:
        if(t < 0.25) return `rgb(0, ${Math.floor(t*4*255)}, 255)`;
        if(t < 0.5) return `rgb(0, 255, ${Math.floor((0.5-t)*4*255)})`;
        if(t < 0.75) return `rgb(${Math.floor((t-0.5)*4*255)}, 255, 0)`;
        return `rgb(255, ${Math.floor((1-t)*4*255)}, 0)`;
    },

    log(msg) {
        const c = document.getElementById('console_out');
        c.textContent += msg + "\n";
        c.scrollTop = c.scrollHeight;
    }
};

// Start
window.onload = () => App.init();

</script>
</body>
</html>
